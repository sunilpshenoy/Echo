{"version":3,"file":"static/js/544.1bf154ec.chunk.js","mappings":"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","sources":["../node_modules/qr-scanner/src/qr-scanner.ts"],"sourcesContent":["class QrScanner {\n    static readonly DEFAULT_CANVAS_SIZE = 400;\n    static readonly NO_QR_CODE_FOUND = 'No QR code found';\n    private static _disableBarcodeDetector = false;\n    private static _workerMessageId = 0;\n\n    /** @deprecated */\n    static set WORKER_PATH(workerPath: string) {\n        console.warn('Setting QrScanner.WORKER_PATH is not required and not supported anymore. '\n            + 'Have a look at the README for new setup instructions.');\n    }\n\n    static async hasCamera(): Promise<boolean> {\n        try {\n            return !!(await QrScanner.listCameras(false)).length;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    static async listCameras(requestLabels = false): Promise<Array<QrScanner.Camera>> {\n        if (!navigator.mediaDevices) return [];\n\n        const enumerateCameras = async (): Promise<Array<MediaDeviceInfo>> =>\n            (await navigator.mediaDevices.enumerateDevices()).filter((device) => device.kind === 'videoinput');\n\n        // Note that enumerateDevices can always be called and does not prompt the user for permission.\n        // However, enumerateDevices only includes device labels if served via https and an active media stream exists\n        // or permission to access the camera was given. Therefore, if we're not getting labels but labels are requested\n        // ask for camera permission by opening a stream.\n        let openedStream: MediaStream | undefined;\n        try {\n            if (requestLabels && (await enumerateCameras()).every((camera) => !camera.label)) {\n                openedStream = await navigator.mediaDevices.getUserMedia({ audio: false, video: true });\n            }\n        } catch (e) {\n            // Fail gracefully, especially if the device has no camera or on mobile when the camera is already in use\n            // and some browsers disallow a second stream.\n        }\n\n        try {\n            return (await enumerateCameras()).map((camera, i) => ({\n                id: camera.deviceId,\n                label: camera.label || (i === 0 ? 'Default Camera' : `Camera ${i + 1}`),\n            }));\n        } finally {\n            // close the stream we just opened for getting camera access for listing the device labels\n            if (openedStream) {\n                console.warn('Call listCameras after successfully starting a QR scanner to avoid creating '\n                    + 'a temporary video stream');\n                QrScanner._stopVideoStream(openedStream);\n            }\n        }\n    }\n\n    readonly $video: HTMLVideoElement;\n    readonly $canvas: HTMLCanvasElement;\n    readonly $overlay?: HTMLDivElement;\n    private readonly $codeOutlineHighlight?: SVGSVGElement;\n    private readonly _onDecode?: (result: QrScanner.ScanResult) => void;\n    private readonly _legacyOnDecode?: (result: string) => void;\n    private readonly _legacyCanvasSize: number = QrScanner.DEFAULT_CANVAS_SIZE;\n    private _preferredCamera: QrScanner.FacingMode | QrScanner.DeviceId = 'environment';\n    private readonly _maxScansPerSecond: number = 25;\n    private _lastScanTimestamp: number = -1;\n    private _scanRegion: QrScanner.ScanRegion;\n    private _codeOutlineHighlightRemovalTimeout?: number;\n    private _qrEnginePromise: Promise<Worker | BarcodeDetector>\n    private _active: boolean = false;\n    private _paused: boolean = false;\n    private _flashOn: boolean = false;\n    private _destroyed: boolean = false;\n\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: (result: QrScanner.ScanResult) => void,\n        options: {\n            onDecodeError?: (error: Error | string) => void,\n            calculateScanRegion?: (video: HTMLVideoElement) => QrScanner.ScanRegion,\n            preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n            maxScansPerSecond?: number;\n            highlightScanRegion?: boolean,\n            highlightCodeOutline?: boolean,\n            overlay?: HTMLDivElement,\n            /** just a temporary flag until we switch entirely to the new api */\n            returnDetailedScanResult?: true,\n        },\n    );\n    /** @deprecated */\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: (result: string) => void,\n        onDecodeError?: (error: Error | string) => void,\n        calculateScanRegion?: (video: HTMLVideoElement) => QrScanner.ScanRegion,\n        preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n    );\n    /** @deprecated */\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: (result: string) => void,\n        onDecodeError?: (error: Error | string) => void,\n        canvasSize?: number,\n        preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n    );\n    /** @deprecated */\n    constructor(video: HTMLVideoElement, onDecode: (result: string) => void, canvasSize?: number);\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: ((result: QrScanner.ScanResult) => void) | ((result: string) => void),\n        canvasSizeOrOnDecodeErrorOrOptions?: number | ((error: Error | string) => void) | {\n            onDecodeError?: (error: Error | string) => void,\n            calculateScanRegion?: (video: HTMLVideoElement) => QrScanner.ScanRegion,\n            preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n            maxScansPerSecond?: number;\n            highlightScanRegion?: boolean,\n            highlightCodeOutline?: boolean,\n            overlay?: HTMLDivElement,\n            /** just a temporary flag until we switch entirely to the new api */\n            returnDetailedScanResult?: true,\n        },\n        canvasSizeOrCalculateScanRegion?: number | ((video: HTMLVideoElement) => QrScanner.ScanRegion),\n        preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n    ) {\n        this.$video = video;\n        this.$canvas = document.createElement('canvas');\n\n        if (canvasSizeOrOnDecodeErrorOrOptions && typeof canvasSizeOrOnDecodeErrorOrOptions === 'object') {\n            // we got an options object using the new api\n            this._onDecode = onDecode as QrScanner['_onDecode'];\n        } else {\n            if (canvasSizeOrOnDecodeErrorOrOptions || canvasSizeOrCalculateScanRegion || preferredCamera) {\n                console.warn('You\\'re using a deprecated version of the QrScanner constructor which will be removed in '\n                    + 'the future');\n            } else {\n                // Only video and onDecode were specified and we can't distinguish between new or old api usage. For\n                // backwards compatibility we have to assume the old api for now. The options object is marked as non-\n                // optional in the parameter list above to make clear that ScanResult instead of string is only passed\n                // if an options object was provided. However, in the future once legacy support is removed, the options\n                // object should become optional.\n                console.warn('Note that the type of the scan result passed to onDecode will change in the future. '\n                    + 'To already switch to the new api today, you can pass returnDetailedScanResult: true.');\n            }\n            this._legacyOnDecode = onDecode as QrScanner['_legacyOnDecode'];\n        }\n\n        const options = typeof canvasSizeOrOnDecodeErrorOrOptions === 'object'\n            ? canvasSizeOrOnDecodeErrorOrOptions\n            : {};\n        this._onDecodeError = options.onDecodeError || (typeof canvasSizeOrOnDecodeErrorOrOptions === 'function'\n            ? canvasSizeOrOnDecodeErrorOrOptions\n            : this._onDecodeError);\n        this._calculateScanRegion = options.calculateScanRegion || (typeof canvasSizeOrCalculateScanRegion==='function'\n            ? canvasSizeOrCalculateScanRegion\n            : this._calculateScanRegion);\n        this._preferredCamera = options.preferredCamera || preferredCamera || this._preferredCamera;\n        this._legacyCanvasSize = typeof canvasSizeOrOnDecodeErrorOrOptions === 'number'\n            ? canvasSizeOrOnDecodeErrorOrOptions\n            : typeof canvasSizeOrCalculateScanRegion === 'number'\n                ? canvasSizeOrCalculateScanRegion\n                : this._legacyCanvasSize;\n        this._maxScansPerSecond = options.maxScansPerSecond || this._maxScansPerSecond;\n\n        this._onPlay = this._onPlay.bind(this);\n        this._onLoadedMetaData = this._onLoadedMetaData.bind(this);\n        this._onVisibilityChange = this._onVisibilityChange.bind(this);\n        this._updateOverlay = this._updateOverlay.bind(this);\n\n        // @ts-ignore\n        video.disablePictureInPicture = true;\n        // Allow inline playback on iPhone instead of requiring full screen playback,\n        // see https://webkit.org/blog/6784/new-video-policies-for-ios/\n        // @ts-ignore\n        video.playsInline = true;\n        // Allow play() on iPhone without requiring a user gesture. Should not really be needed as camera stream\n        // includes no audio, but just to be safe.\n        video.muted = true;\n\n        // Avoid Safari stopping the video stream on a hidden video.\n        // See https://github.com/cozmo/jsQR/issues/185\n        let shouldHideVideo = false;\n        if (video.hidden) {\n            video.hidden = false;\n            shouldHideVideo = true;\n        }\n        if (!document.body.contains(video)) {\n            document.body.appendChild(video);\n            shouldHideVideo = true;\n        }\n        const videoContainer = video.parentElement!;\n\n        if (options.highlightScanRegion || options.highlightCodeOutline) {\n            const gotExternalOverlay = !!options.overlay;\n            this.$overlay = options.overlay || document.createElement('div');\n            const overlayStyle = this.$overlay.style;\n            overlayStyle.position = 'absolute';\n            overlayStyle.display = 'none';\n            overlayStyle.pointerEvents = 'none';\n            this.$overlay.classList.add('scan-region-highlight');\n            if (!gotExternalOverlay && options.highlightScanRegion) {\n                // default style; can be overwritten via css, e.g. by changing the svg's stroke color, hiding the\n                // .scan-region-highlight-svg, setting a border, outline, background, etc.\n                this.$overlay.innerHTML = '<svg class=\"scan-region-highlight-svg\" viewBox=\"0 0 238 238\" '\n                    + 'preserveAspectRatio=\"none\" style=\"position:absolute;width:100%;height:100%;left:0;top:0;'\n                    + 'fill:none;stroke:#e9b213;stroke-width:4;stroke-linecap:round;stroke-linejoin:round\">'\n                    + '<path d=\"M31 2H10a8 8 0 0 0-8 8v21M207 2h21a8 8 0 0 1 8 8v21m0 176v21a8 8 0 0 1-8 8h-21m-176 '\n                    + '0H10a8 8 0 0 1-8-8v-21\"/></svg>';\n                try {\n                    this.$overlay.firstElementChild!.animate({ transform: ['scale(.98)', 'scale(1.01)'] }, {\n                        duration: 400,\n                        iterations: Infinity,\n                        direction: 'alternate',\n                        easing: 'ease-in-out',\n                    });\n                } catch (e) {}\n                videoContainer.insertBefore(this.$overlay, this.$video.nextSibling);\n            }\n            if (options.highlightCodeOutline) {\n                // default style; can be overwritten via css\n                this.$overlay.insertAdjacentHTML(\n                    'beforeend',\n                    '<svg class=\"code-outline-highlight\" preserveAspectRatio=\"none\" style=\"display:none;width:100%;'\n                        + 'height:100%;fill:none;stroke:#e9b213;stroke-width:5;stroke-dasharray:25;'\n                        + 'stroke-linecap:round;stroke-linejoin:round\"><polygon/></svg>',\n                );\n                this.$codeOutlineHighlight = this.$overlay.lastElementChild as SVGSVGElement;\n            }\n        }\n        this._scanRegion = this._calculateScanRegion(video);\n\n        requestAnimationFrame(() => {\n            // Checking in requestAnimationFrame which should avoid a potential additional re-flow for getComputedStyle.\n            const videoStyle = window.getComputedStyle(video);\n            if (videoStyle.display === 'none') {\n                video.style.setProperty('display', 'block', 'important');\n                shouldHideVideo = true;\n            }\n            if (videoStyle.visibility !== 'visible') {\n                video.style.setProperty('visibility', 'visible', 'important');\n                shouldHideVideo = true;\n            }\n            if (shouldHideVideo) {\n                // Hide the video in a way that doesn't cause Safari to stop the playback.\n                console.warn('QrScanner has overwritten the video hiding style to avoid Safari stopping the playback.');\n                video.style.opacity = '0';\n                video.style.width = '0';\n                video.style.height = '0';\n                if (this.$overlay && this.$overlay.parentElement) {\n                    this.$overlay.parentElement.removeChild(this.$overlay);\n                }\n                // @ts-ignore\n                delete this.$overlay!;\n                // @ts-ignore\n                delete this.$codeOutlineHighlight!;\n            }\n\n            if (this.$overlay) {\n                this._updateOverlay();\n            }\n        });\n\n        video.addEventListener('play', this._onPlay);\n        video.addEventListener('loadedmetadata', this._onLoadedMetaData);\n        document.addEventListener('visibilitychange', this._onVisibilityChange);\n        window.addEventListener('resize', this._updateOverlay);\n\n        this._qrEnginePromise = QrScanner.createQrEngine();\n    }\n\n    async hasFlash(): Promise<boolean> {\n        let stream: MediaStream | undefined;\n        try {\n            if (this.$video.srcObject) {\n                if (!(this.$video.srcObject instanceof MediaStream)) return false; // srcObject is not a camera stream\n                stream = this.$video.srcObject;\n            } else {\n                stream = (await this._getCameraStream()).stream;\n            }\n            return 'torch' in stream.getVideoTracks()[0].getSettings();\n        } catch (e) {\n            return false;\n        } finally {\n            // close the stream we just opened for detecting whether it supports flash\n            if (stream && stream !== this.$video.srcObject) {\n                console.warn('Call hasFlash after successfully starting the scanner to avoid creating '\n                    + 'a temporary video stream');\n                QrScanner._stopVideoStream(stream);\n            }\n        }\n    }\n\n    isFlashOn(): boolean {\n        return this._flashOn;\n    }\n\n    async toggleFlash(): Promise<void> {\n        if (this._flashOn) {\n            await this.turnFlashOff();\n        } else {\n            await this.turnFlashOn();\n        }\n    }\n\n    async turnFlashOn(): Promise<void> {\n        if (this._flashOn || this._destroyed) return;\n        this._flashOn = true;\n        if (!this._active || this._paused) return; // flash will be turned on later on .start()\n        try {\n            if (!await this.hasFlash()) throw 'No flash available';\n            // Note that the video track is guaranteed to exist and to be a MediaStream due to the check in hasFlash\n            await (this.$video.srcObject as MediaStream).getVideoTracks()[0].applyConstraints({\n                // @ts-ignore: constraint 'torch' is unknown to ts\n                advanced: [{ torch: true }],\n            });\n        } catch (e) {\n            this._flashOn = false;\n            throw e;\n        }\n    }\n\n    async turnFlashOff(): Promise<void> {\n        if (!this._flashOn) return;\n        // applyConstraints with torch: false does not work to turn the flashlight off, as a stream's torch stays\n        // continuously on, see https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#torch. Therefore,\n        // we have to stop the stream to turn the flashlight off.\n        this._flashOn = false;\n        await this._restartVideoStream();\n    }\n\n    destroy(): void {\n        this.$video.removeEventListener('loadedmetadata', this._onLoadedMetaData);\n        this.$video.removeEventListener('play', this._onPlay);\n        document.removeEventListener('visibilitychange', this._onVisibilityChange);\n        window.removeEventListener('resize', this._updateOverlay);\n\n        this._destroyed = true;\n        this._flashOn = false;\n        this.stop(); // sets this._paused = true and this._active = false\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'close');\n    }\n\n    async start(): Promise<void> {\n        if (this._destroyed) throw new Error('The QR scanner can not be started as it had been destroyed.');\n        if (this._active && !this._paused) return;\n\n        if (window.location.protocol !== 'https:') {\n            // warn but try starting the camera anyways\n            console.warn('The camera stream is only accessible if the page is transferred via https.');\n        }\n\n        this._active = true;\n        if (document.hidden) return; // camera will be started as soon as tab is in foreground\n        this._paused = false;\n        if (this.$video.srcObject) {\n            // camera stream already/still set\n            await this.$video.play();\n            return;\n        }\n\n        try {\n            const { stream, facingMode } = await this._getCameraStream();\n            if (!this._active || this._paused) {\n                // was stopped in the meantime\n                QrScanner._stopVideoStream(stream);\n                return;\n            }\n            this._setVideoMirror(facingMode);\n            this.$video.srcObject = stream;\n            await this.$video.play();\n\n            // Restart the flash if it was previously on\n            if (this._flashOn) {\n                this._flashOn = false; // force turnFlashOn to restart the flash\n                this.turnFlashOn().catch(() => {});\n            }\n        } catch (e) {\n            if (this._paused) return;\n            this._active = false;\n            throw e;\n        }\n    }\n\n    stop(): void {\n        this.pause();\n        this._active = false;\n    }\n\n    async pause(stopStreamImmediately = false): Promise<boolean> {\n        this._paused = true;\n        if (!this._active) return true;\n        this.$video.pause();\n\n        if (this.$overlay) {\n            this.$overlay.style.display = 'none';\n        }\n\n        const stopStream = () => {\n            if (this.$video.srcObject instanceof MediaStream) {\n                // revoke srcObject only if it's a stream which was likely set by us\n                QrScanner._stopVideoStream(this.$video.srcObject);\n                this.$video.srcObject = null;\n            }\n        };\n\n        if (stopStreamImmediately) {\n            stopStream();\n            return true;\n        }\n\n        await new Promise((resolve) => setTimeout(resolve, 300));\n        if (!this._paused) return false;\n        stopStream();\n        return true;\n    }\n\n    async setCamera(facingModeOrDeviceId: QrScanner.FacingMode | QrScanner.DeviceId): Promise<void> {\n        if (facingModeOrDeviceId === this._preferredCamera) return;\n        this._preferredCamera = facingModeOrDeviceId;\n        // Restart the scanner with the new camera which will also update the video mirror and the scan region.\n        await this._restartVideoStream();\n    }\n\n    static async scanImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n        options: {\n            scanRegion?: QrScanner.ScanRegion | null,\n            qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\n            canvas?: HTMLCanvasElement | null,\n            disallowCanvasResizing?: boolean,\n            alsoTryWithoutScanRegion?: boolean,\n            /** just a temporary flag until we switch entirely to the new api */\n            returnDetailedScanResult?: true,\n        },\n    ): Promise<QrScanner.ScanResult>;\n    /** @deprecated */\n    static async scanImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n        scanRegion?: QrScanner.ScanRegion | null,\n        qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\n        canvas?: HTMLCanvasElement | null,\n        disallowCanvasResizing?: boolean,\n        alsoTryWithoutScanRegion?: boolean,\n    ): Promise<string>;\n    static async scanImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n        scanRegionOrOptions?: QrScanner.ScanRegion | {\n            scanRegion?: QrScanner.ScanRegion | null,\n            qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\n            canvas?: HTMLCanvasElement | null,\n            disallowCanvasResizing?: boolean,\n            alsoTryWithoutScanRegion?: boolean,\n            /** just a temporary flag until we switch entirely to the new api */\n            returnDetailedScanResult?: true,\n        } | null,\n        qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\n        canvas?: HTMLCanvasElement | null,\n        disallowCanvasResizing: boolean = false,\n        alsoTryWithoutScanRegion: boolean = false,\n    ): Promise<string | QrScanner.ScanResult> {\n        let scanRegion: QrScanner.ScanRegion | null | undefined;\n        let returnDetailedScanResult = false;\n        if (scanRegionOrOptions && (\n            'scanRegion' in scanRegionOrOptions\n            || 'qrEngine' in scanRegionOrOptions\n            || 'canvas' in scanRegionOrOptions\n            || 'disallowCanvasResizing' in scanRegionOrOptions\n            || 'alsoTryWithoutScanRegion' in scanRegionOrOptions\n            || 'returnDetailedScanResult' in scanRegionOrOptions\n        )) {\n            // we got an options object using the new api\n            scanRegion = scanRegionOrOptions.scanRegion;\n            qrEngine = scanRegionOrOptions.qrEngine;\n            canvas = scanRegionOrOptions.canvas;\n            disallowCanvasResizing = scanRegionOrOptions.disallowCanvasResizing || false;\n            alsoTryWithoutScanRegion = scanRegionOrOptions.alsoTryWithoutScanRegion || false;\n            returnDetailedScanResult = true;\n        } else if (scanRegionOrOptions || qrEngine || canvas || disallowCanvasResizing || alsoTryWithoutScanRegion) {\n            console.warn('You\\'re using a deprecated api for scanImage which will be removed in the future.');\n        } else {\n            // Only imageOrFileOrBlobOrUrl was specified and we can't distinguish between new or old api usage. For\n            // backwards compatibility we have to assume the old api for now. The options object is marked as non-\n            // optional in the parameter list above to make clear that ScanResult instead of string is only returned if\n            // an options object was provided. However, in the future once legacy support is removed, the options object\n            // should become optional.\n            console.warn('Note that the return type of scanImage will change in the future. To already switch to the '\n                + 'new api today, you can pass returnDetailedScanResult: true.');\n        }\n\n        const gotExternalEngine = !!qrEngine;\n\n        try {\n            let image: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n                | SVGImageElement;\n            let canvasContext: CanvasRenderingContext2D;\n            [qrEngine, image] = await Promise.all([\n                qrEngine || QrScanner.createQrEngine(),\n                QrScanner._loadImage(imageOrFileOrBlobOrUrl),\n            ]);\n            [canvas, canvasContext] = QrScanner._drawToCanvas(image, scanRegion, canvas, disallowCanvasResizing);\n            let detailedScanResult: QrScanner.ScanResult;\n\n            if (qrEngine instanceof Worker) {\n                const qrEngineWorker = qrEngine; // for ts to know that it's still a worker later in the event listeners\n                if (!gotExternalEngine) {\n                    // Enable scanning of inverted color qr codes.\n                    QrScanner._postWorkerMessageSync(qrEngineWorker, 'inversionMode', 'both');\n                }\n                detailedScanResult = await new Promise((resolve, reject) => {\n                    let timeout: number;\n                    let onMessage: (event: MessageEvent) => void;\n                    let onError: (error: ErrorEvent | string) => void;\n                    let expectedResponseId = -1;\n                    onMessage = (event: MessageEvent) => {\n                        if (event.data.id !== expectedResponseId) {\n                            return;\n                        }\n                        qrEngineWorker.removeEventListener('message', onMessage);\n                        qrEngineWorker.removeEventListener('error', onError);\n                        clearTimeout(timeout);\n                        if (event.data.data !== null) {\n                            resolve({\n                                data: event.data.data,\n                                cornerPoints: QrScanner._convertPoints(event.data.cornerPoints, scanRegion),\n                            });\n                        } else {\n                            reject(QrScanner.NO_QR_CODE_FOUND);\n                        }\n                    };\n                    onError = (error: ErrorEvent | string) => {\n                        qrEngineWorker.removeEventListener('message', onMessage);\n                        qrEngineWorker.removeEventListener('error', onError);\n                        clearTimeout(timeout);\n                        const errorMessage = !error ? 'Unknown Error' : ((error as ErrorEvent).message || error);\n                        reject('Scanner error: ' + errorMessage);\n                    };\n                    qrEngineWorker.addEventListener('message', onMessage);\n                    qrEngineWorker.addEventListener('error', onError);\n                    timeout = setTimeout(() => onError('timeout'), 10000);\n                    const imageData = canvasContext.getImageData(0, 0, canvas!.width, canvas!.height);\n                    expectedResponseId = QrScanner._postWorkerMessageSync(\n                        qrEngineWorker,\n                        'decode',\n                        imageData,\n                        [imageData.data.buffer],\n                    );\n                });\n            } else {\n                detailedScanResult = await Promise.race([\n                    new Promise<QrScanner.ScanResult>((resolve, reject) => window.setTimeout(\n                        () => reject('Scanner error: timeout'),\n                        10000,\n                    )),\n                    (async (): Promise<QrScanner.ScanResult> => {\n                        try {\n                            const [scanResult] = await qrEngine.detect(canvas!);\n                            if (!scanResult) throw QrScanner.NO_QR_CODE_FOUND;\n                            return {\n                                data: scanResult.rawValue,\n                                cornerPoints: QrScanner._convertPoints(scanResult.cornerPoints, scanRegion),\n                            };\n                        } catch (e) {\n                            const errorMessage = (e as Error).message || e as string;\n                            if (/not implemented|service unavailable/.test(errorMessage)) {\n                                // Not implemented can apparently for some reason happen even though getSupportedFormats\n                                // in createQrScanner reported that it's supported, see issue #98.\n                                // Service unavailable can happen after some time when the BarcodeDetector crashed and\n                                // can theoretically be recovered from by creating a new BarcodeDetector. However, in\n                                // newer browsers this issue does not seem to be present anymore and therefore we do not\n                                // apply this optimization anymore but just set _disableBarcodeDetector in both cases.\n                                // Also note that if we got an external qrEngine that crashed, we should possibly notify\n                                // the caller about it, but we also don't do this here, as it's such an unlikely case.\n                                QrScanner._disableBarcodeDetector = true;\n                                // retry without passing the broken BarcodeScanner instance\n                                return QrScanner.scanImage(imageOrFileOrBlobOrUrl, {\n                                    scanRegion,\n                                    canvas,\n                                    disallowCanvasResizing,\n                                    alsoTryWithoutScanRegion,\n                                });\n                            }\n                            throw `Scanner error: ${errorMessage}`;\n                        }\n                    })(),\n                ]);\n            }\n            return returnDetailedScanResult ? detailedScanResult : detailedScanResult.data;\n        } catch (e) {\n            if (!scanRegion || !alsoTryWithoutScanRegion) throw e;\n            const detailedScanResult = await QrScanner.scanImage(\n                imageOrFileOrBlobOrUrl,\n                { qrEngine, canvas, disallowCanvasResizing },\n            );\n            return returnDetailedScanResult ? detailedScanResult : detailedScanResult.data;\n        } finally {\n            if (!gotExternalEngine) {\n                QrScanner._postWorkerMessage(qrEngine!, 'close');\n            }\n        }\n    }\n\n    setGrayscaleWeights(red: number, green: number, blue: number, useIntegerApproximation: boolean = true): void {\n        // Note that for the native BarcodeDecoder or if the worker was destroyed, this is a no-op. However, the native\n        // implementations work also well with colored qr codes.\n        QrScanner._postWorkerMessage(\n            this._qrEnginePromise,\n            'grayscaleWeights',\n            { red, green, blue, useIntegerApproximation }\n        );\n    }\n\n    setInversionMode(inversionMode: QrScanner.InversionMode): void {\n        // Note that for the native BarcodeDecoder or if the worker was destroyed, this is a no-op. However, the native\n        // implementations scan normal and inverted qr codes by default\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'inversionMode', inversionMode);\n    }\n\n    static async createQrEngine(): Promise<Worker | BarcodeDetector>;\n    /** @deprecated */\n    static async createQrEngine(workerPath: string): Promise<Worker | BarcodeDetector>;\n    static async createQrEngine(workerPath?: string): Promise<Worker | BarcodeDetector> {\n        if (workerPath) {\n            console.warn('Specifying a worker path is not required and not supported anymore.');\n        }\n\n        // @ts-ignore no types defined for import\n        const createWorker = () => (import('./qr-scanner-worker.min.js') as Promise<{ createWorker: () => Worker }>)\n            .then((module) => module.createWorker());\n\n        const useBarcodeDetector = !QrScanner._disableBarcodeDetector\n            && 'BarcodeDetector' in window\n            && BarcodeDetector.getSupportedFormats\n            && (await BarcodeDetector.getSupportedFormats()).includes('qr_code');\n\n        if (!useBarcodeDetector) return createWorker();\n\n        // On Macs with an M1/M2 processor and macOS Ventura (macOS version 13), the BarcodeDetector is broken in\n        // Chromium based browsers, regardless of the version. For that constellation, the BarcodeDetector does not\n        // error but does not detect QR codes. Macs without an M1/M2 or before Ventura are fine.\n        // See issue #209 and https://bugs.chromium.org/p/chromium/issues/detail?id=1382442\n        // TODO update this once the issue in macOS is fixed\n        const userAgentData = navigator.userAgentData;\n        const isChromiumOnMacWithArmVentura = userAgentData // all Chromium browsers support userAgentData\n            && userAgentData.brands.some(({ brand }) => /Chromium/i.test(brand))\n            && /mac ?OS/i.test(userAgentData.platform)\n            // Does it have an ARM chip (e.g. M1/M2) and Ventura? Check this last as getHighEntropyValues can\n            // theoretically trigger a browser prompt, although no browser currently does seem to show one.\n            // If browser or user refused to return the requested values, assume broken ARM Ventura, to be safe.\n            && await userAgentData.getHighEntropyValues(['architecture', 'platformVersion'])\n                .then(({ architecture, platformVersion }) =>\n                    /arm/i.test(architecture || 'arm') && parseInt(platformVersion || '13') >= /* Ventura */ 13)\n                .catch(() => true);\n        if (isChromiumOnMacWithArmVentura) return createWorker();\n\n        return new BarcodeDetector({ formats: ['qr_code'] });\n    }\n\n    private _onPlay(): void {\n        this._scanRegion = this._calculateScanRegion(this.$video);\n        this._updateOverlay();\n        if (this.$overlay) {\n            this.$overlay.style.display = '';\n        }\n        this._scanFrame();\n    }\n\n    private _onLoadedMetaData(): void {\n        this._scanRegion = this._calculateScanRegion(this.$video);\n        this._updateOverlay();\n    }\n\n    private _onVisibilityChange(): void {\n        if (document.hidden) {\n            this.pause();\n        } else if (this._active) {\n            this.start();\n        }\n    }\n\n    private _calculateScanRegion(video: HTMLVideoElement): QrScanner.ScanRegion {\n        // Default scan region calculation. Note that this can be overwritten in the constructor.\n        const smallestDimension = Math.min(video.videoWidth, video.videoHeight);\n        const scanRegionSize = Math.round(2 / 3 * smallestDimension);\n        return {\n            x: Math.round((video.videoWidth - scanRegionSize) / 2),\n            y: Math.round((video.videoHeight - scanRegionSize) / 2),\n            width: scanRegionSize,\n            height: scanRegionSize,\n            downScaledWidth: this._legacyCanvasSize,\n            downScaledHeight: this._legacyCanvasSize,\n        };\n    }\n\n    private _updateOverlay(): void {\n        requestAnimationFrame(() => {\n            // Running in requestAnimationFrame which should avoid a potential additional re-flow for getComputedStyle\n            // and offsetWidth, offsetHeight, offsetLeft, offsetTop.\n            if (!this.$overlay) return;\n            const video = this.$video;\n            const videoWidth = video.videoWidth;\n            const videoHeight = video.videoHeight;\n            const elementWidth = video.offsetWidth;\n            const elementHeight = video.offsetHeight;\n            const elementX = video.offsetLeft;\n            const elementY = video.offsetTop;\n\n            const videoStyle = window.getComputedStyle(video);\n            const videoObjectFit = videoStyle.objectFit;\n            const videoAspectRatio = videoWidth / videoHeight;\n            const elementAspectRatio = elementWidth / elementHeight;\n            let videoScaledWidth: number;\n            let videoScaledHeight: number;\n            switch (videoObjectFit) {\n                case 'none':\n                    videoScaledWidth = videoWidth;\n                    videoScaledHeight = videoHeight;\n                    break;\n                case 'fill':\n                    videoScaledWidth = elementWidth;\n                    videoScaledHeight = elementHeight;\n                    break;\n                default: // 'cover', 'contains', 'scale-down'\n                    if (videoObjectFit === 'cover'\n                        ? videoAspectRatio > elementAspectRatio\n                        : videoAspectRatio < elementAspectRatio) {\n                        // The scaled height is the element height\n                        // - for 'cover' if the video aspect ratio is wider than the element aspect ratio\n                        //   (scaled height matches element height and scaled width overflows element width)\n                        // - for 'contains'/'scale-down' if element aspect ratio is wider than the video aspect ratio\n                        //   (scaled height matched element height and element width overflows scaled width)\n                        videoScaledHeight = elementHeight;\n                        videoScaledWidth = videoScaledHeight * videoAspectRatio;\n                    } else {\n                        videoScaledWidth = elementWidth;\n                        videoScaledHeight = videoScaledWidth / videoAspectRatio;\n                    }\n                    if (videoObjectFit === 'scale-down') {\n                        // for 'scale-down' the dimensions are the minimum of 'contains' and 'none'\n                        videoScaledWidth = Math.min(videoScaledWidth, videoWidth);\n                        videoScaledHeight = Math.min(videoScaledHeight, videoHeight);\n                    }\n            }\n\n            // getComputedStyle is so nice to convert keywords (left, center, right, top, bottom) to percent and makes\n            // sure to set the default of 50% if only one or no component was provided, therefore we can be sure that\n            // both components are set. Additionally, it converts units other than px (e.g. rem) to px.\n            const [videoX, videoY] = videoStyle.objectPosition.split(' ').map((length, i) => {\n                const lengthValue = parseFloat(length);\n                return length.endsWith('%')\n                    ? (!i ? elementWidth - videoScaledWidth : elementHeight - videoScaledHeight) * lengthValue / 100\n                    : lengthValue;\n            });\n\n            const regionWidth = this._scanRegion.width || videoWidth;\n            const regionHeight = this._scanRegion.height || videoHeight;\n            const regionX = this._scanRegion.x || 0;\n            const regionY = this._scanRegion.y || 0;\n\n            const overlayStyle = this.$overlay.style;\n            overlayStyle.width = `${regionWidth / videoWidth * videoScaledWidth}px`;\n            overlayStyle.height = `${regionHeight / videoHeight * videoScaledHeight}px`;\n            overlayStyle.top = `${elementY + videoY + regionY / videoHeight * videoScaledHeight}px`;\n            const isVideoMirrored = /scaleX\\(-1\\)/.test(video.style.transform!);\n            overlayStyle.left = `${elementX\n                + (isVideoMirrored ? elementWidth - videoX - videoScaledWidth : videoX)\n                + (isVideoMirrored ? videoWidth - regionX - regionWidth : regionX) / videoWidth * videoScaledWidth}px`;\n            // apply same mirror as on video\n            overlayStyle.transform = video.style.transform;\n        });\n    }\n\n    private static _convertPoints(\n        points: QrScanner.Point[],\n        scanRegion?: QrScanner.ScanRegion | null,\n    ): QrScanner.Point[] {\n        if (!scanRegion) return points;\n        const offsetX = scanRegion.x || 0;\n        const offsetY = scanRegion.y || 0;\n        const scaleFactorX = scanRegion.width && scanRegion.downScaledWidth\n            ? scanRegion.width / scanRegion.downScaledWidth\n            : 1;\n        const scaleFactorY = scanRegion.height && scanRegion.downScaledHeight\n            ? scanRegion.height / scanRegion.downScaledHeight\n            : 1;\n        for (const point of points) {\n            point.x = point.x * scaleFactorX + offsetX;\n            point.y = point.y * scaleFactorY + offsetY;\n        }\n        return points;\n    }\n\n    private _scanFrame(): void {\n        if (!this._active || this.$video.paused || this.$video.ended) return;\n        // If requestVideoFrameCallback is available use that to avoid unnecessary scans on the same frame as the\n        // camera's framerate can be lower than the screen refresh rate and this._maxScansPerSecond, especially in dark\n        // settings where the exposure time is longer. Both, requestVideoFrameCallback and requestAnimationFrame are not\n        // being fired if the tab is in the background, which is what we want.\n        const requestFrame = 'requestVideoFrameCallback' in this.$video\n            // @ts-ignore\n            ? this.$video.requestVideoFrameCallback.bind(this.$video)\n            : requestAnimationFrame;\n        requestFrame(async () => {\n            if (this.$video.readyState <= 1) {\n                // Skip scans until the video is ready as drawImage() only works correctly on a video with readyState\n                // > 1, see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage#Notes.\n                // This also avoids false positives for videos paused after a successful scan which remains visible on\n                // the canvas until the video is started again and ready.\n                this._scanFrame();\n                return;\n            }\n\n            const timeSinceLastScan = Date.now() - this._lastScanTimestamp;\n            const minimumTimeBetweenScans = 1000 / this._maxScansPerSecond;\n            if (timeSinceLastScan < minimumTimeBetweenScans) {\n                await new Promise((resolve) => setTimeout(resolve, minimumTimeBetweenScans - timeSinceLastScan));\n            }\n            // console.log('Scan rate:', Math.round(1000 / (Date.now() - this._lastScanTimestamp)));\n            this._lastScanTimestamp = Date.now();\n\n            let result: QrScanner.ScanResult | undefined;\n            try {\n                result = await QrScanner.scanImage(this.$video, {\n                    scanRegion: this._scanRegion,\n                    qrEngine: this._qrEnginePromise,\n                    canvas: this.$canvas,\n                });\n            } catch (error) {\n                if (!this._active) return;\n                this._onDecodeError(error as Error | string);\n            }\n\n            if (QrScanner._disableBarcodeDetector && !(await this._qrEnginePromise instanceof Worker)) {\n                // replace the disabled BarcodeDetector\n                this._qrEnginePromise = QrScanner.createQrEngine();\n            }\n\n            if (result) {\n                if (this._onDecode) {\n                    this._onDecode(result);\n                } else if (this._legacyOnDecode) {\n                    this._legacyOnDecode(result.data);\n                }\n\n                if (this.$codeOutlineHighlight) {\n                    clearTimeout(this._codeOutlineHighlightRemovalTimeout);\n                    this._codeOutlineHighlightRemovalTimeout = undefined;\n                    this.$codeOutlineHighlight.setAttribute(\n                        'viewBox',\n                        `${this._scanRegion.x || 0} `\n                            + `${this._scanRegion.y || 0} `\n                            + `${this._scanRegion.width || this.$video.videoWidth} `\n                            + `${this._scanRegion.height || this.$video.videoHeight}`,\n                    );\n                    const polygon = this.$codeOutlineHighlight.firstElementChild!;\n                    polygon.setAttribute('points', result.cornerPoints.map(({x, y}) => `${x},${y}`).join(' '));\n                    this.$codeOutlineHighlight.style.display = '';\n                }\n            } else if (this.$codeOutlineHighlight && !this._codeOutlineHighlightRemovalTimeout) {\n                // hide after timeout to make it flash less when on some frames the QR code is detected and on some not\n                this._codeOutlineHighlightRemovalTimeout = setTimeout(\n                    () => this.$codeOutlineHighlight!.style.display = 'none',\n                    100,\n                );\n            }\n\n            this._scanFrame();\n        });\n    }\n\n    private _onDecodeError(error: Error | string): void {\n        // default error handler; can be overwritten in the constructor\n        if (error === QrScanner.NO_QR_CODE_FOUND) return;\n        console.log(error);\n    }\n\n    private async _getCameraStream(): Promise<{ stream: MediaStream, facingMode: QrScanner.FacingMode }> {\n        if (!navigator.mediaDevices) throw 'Camera not found.';\n\n        const preferenceType = /^(environment|user)$/.test(this._preferredCamera)\n            ? 'facingMode'\n            : 'deviceId';\n        const constraintsWithoutCamera: Array<MediaTrackConstraints> = [{\n            width: { min: 1024 }\n        }, {\n            width: { min: 768 }\n        }, {}];\n        const constraintsWithCamera = constraintsWithoutCamera.map((constraint) => Object.assign({}, constraint, {\n            [preferenceType]: { exact: this._preferredCamera },\n        }));\n\n        for (const constraints of [...constraintsWithCamera, ...constraintsWithoutCamera]) {\n            try {\n                const stream = await navigator.mediaDevices.getUserMedia({ video: constraints, audio: false });\n                // Try to determine the facing mode from the stream, otherwise use a guess or 'environment' as\n                // default. Note that the guess is not always accurate as Safari returns cameras of different facing\n                // mode, even for exact facingMode constraints.\n                const facingMode = this._getFacingMode(stream)\n                    || (constraints.facingMode\n                        ? this._preferredCamera as QrScanner.FacingMode // a facing mode we were able to fulfill\n                        : (this._preferredCamera === 'environment'\n                            ? 'user' // switch as _preferredCamera was environment but we are not able to fulfill it\n                            : 'environment' // switch from unfulfilled user facingMode or default to environment\n                        )\n                    );\n                return { stream, facingMode };\n            } catch (e) {}\n        }\n\n        throw 'Camera not found.';\n    }\n\n    private async _restartVideoStream(): Promise<void> {\n        // Note that we always pause the stream and not only if !this._paused as even if this._paused === true, the\n        // stream might still be running, as it's by default only stopped after a delay of 300ms.\n        const wasPaused = this._paused;\n        const paused = await this.pause(true);\n        if (!paused || wasPaused || !this._active) return;\n        await this.start();\n    }\n\n    private static _stopVideoStream(stream : MediaStream): void {\n        for (const track of stream.getTracks()) {\n            track.stop(); //  note that this will also automatically turn the flashlight off\n            stream.removeTrack(track);\n        }\n    }\n\n    private _setVideoMirror(facingMode: QrScanner.FacingMode): void {\n        // in user facing mode mirror the video to make it easier for the user to position the QR code\n        const scaleFactor = facingMode === 'user'? -1 : 1;\n        this.$video.style.transform = 'scaleX(' + scaleFactor + ')';\n    }\n\n    private _getFacingMode(videoStream: MediaStream): QrScanner.FacingMode | null {\n        const videoTrack = videoStream.getVideoTracks()[0];\n        if (!videoTrack) return null; // unknown\n        // inspired by https://github.com/JodusNodus/react-qr-reader/blob/master/src/getDeviceId.js#L13\n        return /rear|back|environment/i.test(videoTrack.label)\n            ? 'environment'\n            : /front|user|face/i.test(videoTrack.label)\n                ? 'user'\n                : null; // unknown\n    }\n\n    private static _drawToCanvas(\n        image: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement,\n        scanRegion?: QrScanner.ScanRegion | null,\n        canvas?: HTMLCanvasElement | null,\n        disallowCanvasResizing= false,\n    ): [HTMLCanvasElement, CanvasRenderingContext2D] {\n        canvas = canvas || document.createElement('canvas');\n        const scanRegionX = scanRegion && scanRegion.x ? scanRegion.x : 0;\n        const scanRegionY = scanRegion && scanRegion.y ? scanRegion.y : 0;\n        const scanRegionWidth = scanRegion && scanRegion.width\n            ? scanRegion.width\n            : (image as HTMLVideoElement).videoWidth || image.width as number;\n        const scanRegionHeight = scanRegion && scanRegion.height\n            ? scanRegion.height\n            : (image as HTMLVideoElement).videoHeight || image.height as number;\n\n        if (!disallowCanvasResizing) {\n            const canvasWidth = scanRegion && scanRegion.downScaledWidth\n                ? scanRegion.downScaledWidth\n                : scanRegionWidth;\n            const canvasHeight = scanRegion && scanRegion.downScaledHeight\n                ? scanRegion.downScaledHeight\n                : scanRegionHeight;\n            // Setting the canvas width or height clears the canvas, even if the values didn't change, therefore only\n            // set them if they actually changed.\n            if (canvas.width !== canvasWidth) {\n                canvas.width = canvasWidth;\n            }\n            if (canvas.height !== canvasHeight) {\n                canvas.height = canvasHeight;\n            }\n        }\n\n        const context = canvas.getContext('2d', { alpha: false })!;\n        context.imageSmoothingEnabled = false; // gives less blurry images\n        context.drawImage(\n            image,\n            scanRegionX, scanRegionY, scanRegionWidth, scanRegionHeight,\n            0, 0, canvas.width, canvas.height,\n        );\n        return [canvas, context];\n    }\n\n    private static async _loadImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n    ): Promise<HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n        | SVGImageElement > {\n        if (imageOrFileOrBlobOrUrl instanceof Image) {\n            await QrScanner._awaitImageLoad(imageOrFileOrBlobOrUrl);\n            return imageOrFileOrBlobOrUrl;\n        } else if (imageOrFileOrBlobOrUrl instanceof HTMLVideoElement\n            || imageOrFileOrBlobOrUrl instanceof HTMLCanvasElement\n            || imageOrFileOrBlobOrUrl instanceof SVGImageElement\n            || 'OffscreenCanvas' in window && imageOrFileOrBlobOrUrl instanceof OffscreenCanvas\n            || 'ImageBitmap' in window && imageOrFileOrBlobOrUrl instanceof ImageBitmap) {\n            return imageOrFileOrBlobOrUrl;\n        } else if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob\n            || imageOrFileOrBlobOrUrl instanceof URL || typeof imageOrFileOrBlobOrUrl === 'string') {\n            const image = new Image();\n            if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                image.src = URL.createObjectURL(imageOrFileOrBlobOrUrl);\n            } else {\n                image.src = imageOrFileOrBlobOrUrl.toString();\n            }\n            try {\n                await QrScanner._awaitImageLoad(image);\n                return image;\n            } finally {\n                if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                    URL.revokeObjectURL(image.src);\n                }\n            }\n        } else {\n            throw 'Unsupported image type.';\n        }\n    }\n\n    private static async _awaitImageLoad(image: HTMLImageElement): Promise<void> {\n        if (image.complete && image.naturalWidth !== 0) return; // already loaded\n        await new Promise<void>((resolve, reject) => {\n            const listener = (event: ErrorEvent | Event) => {\n                image.removeEventListener('load', listener);\n                image.removeEventListener('error', listener);\n                if (event instanceof ErrorEvent) {\n                    reject('Image load error');\n                } else {\n                    resolve();\n                }\n            };\n            image.addEventListener('load', listener);\n            image.addEventListener('error', listener);\n        });\n    }\n\n    private static async _postWorkerMessage(\n        qrEngineOrQrEnginePromise: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector>,\n        type: string,\n        data?: any,\n        transfer?: Transferable[],\n    ): Promise<number> {\n        return QrScanner._postWorkerMessageSync(await qrEngineOrQrEnginePromise, type, data, transfer);\n    }\n\n    // sync version of _postWorkerMessage without performance overhead of async functions\n    private static _postWorkerMessageSync(\n        qrEngine: Worker | BarcodeDetector,\n        type: string,\n        data?: any,\n        transfer?: Transferable[],\n    ): number {\n        if (!(qrEngine instanceof Worker)) return -1;\n        const id = QrScanner._workerMessageId++;\n        qrEngine.postMessage({\n            id,\n            type,\n            data,\n        }, transfer);\n        return id;\n    }\n}\n\ndeclare namespace QrScanner {\n    export interface ScanRegion {\n        x?: number;\n        y?: number;\n        width?: number;\n        height?: number;\n        downScaledWidth?: number;\n        downScaledHeight?: number;\n    }\n\n    export type FacingMode = 'environment' | 'user';\n    export type DeviceId = string;\n\n    export interface Camera {\n        id: DeviceId;\n        label: string;\n    }\n\n    export type InversionMode = 'original' | 'invert' | 'both';\n\n    export interface Point {\n        x: number;\n        y: number;\n    }\n\n    export interface ScanResult {\n        data: string;\n        // In clockwise order, starting at top left, but this might not be guaranteed in the future.\n        cornerPoints: QrScanner.Point[];\n    }\n}\n\n// simplified from https://wicg.github.io/shape-detection-api/#barcode-detection-api\ndeclare class BarcodeDetector {\n    constructor(options?: { formats: string[] });\n    static getSupportedFormats(): Promise<string[]>;\n    detect(image: ImageBitmapSource): Promise<Array<{ rawValue: string, cornerPoints: QrScanner.Point[] }>>;\n}\n\n// simplified from https://github.com/lukewarlow/user-agent-data-types/blob/master/index.d.ts\ndeclare global {\n    interface Navigator {\n        readonly userAgentData?: {\n            readonly platform: string;\n            readonly brands: Array<{\n                readonly brand: string;\n                readonly version: string;\n            }>;\n            getHighEntropyValues(hints: string[]): Promise<{\n                readonly architecture?: string;\n                readonly platformVersion?: string;\n            }>;\n        };\n    }\n}\n\nexport default QrScanner;\n"],"names":["a","b","c","d","f","_legacyCanvasSize","e","DEFAULT_CANVAS_SIZE","_preferredCamera","_maxScansPerSecond","_lastScanTimestamp","_destroyed","_flashOn","_paused","_active","$video","this","$canvas","document","createElement","_onDecode","console","warn","_legacyOnDecode","_onDecodeError","onDecodeError","_calculateScanRegion","calculateScanRegion","preferredCamera","maxScansPerSecond","_onPlay","bind","_onLoadedMetaData","_onVisibilityChange","_updateOverlay","disablePictureInPicture","playsInline","muted","h","hidden","body","contains","appendChild","parentElement","highlightScanRegion","highlightCodeOutline","overlay","$overlay","style","position","display","pointerEvents","classList","add","innerHTML","firstElementChild","animate","transform","duration","iterations","Infinity","direction","easing","m","insertBefore","nextSibling","insertAdjacentHTML","$codeOutlineHighlight","lastElementChild","_scanRegion","requestAnimationFrame","window","getComputedStyle","setProperty","visibility","opacity","width","height","removeChild","addEventListener","_qrEnginePromise","createQrEngine","WORKER_PATH","hasCamera","listCameras","length","arguments","undefined","navigator","mediaDevices","enumerateDevices","filter","kind","every","label","getUserMedia","audio","video","map","id","deviceId","concat","_stopVideoStream","hasFlash","srcObject","MediaStream","_getCameraStream","stream","getVideoTracks","getSettings","isFlashOn","toggleFlash","turnFlashOff","turnFlashOn","applyConstraints","advanced","torch","_restartVideoStream","destroy","removeEventListener","stop","_postWorkerMessage","start","Error","location","protocol","play","facingMode","_setVideoMirror","catch","pause","Promise","setTimeout","setCamera","scanImage","n","scanRegion","qrEngine","canvas","disallowCanvasResizing","alsoTryWithoutScanRegion","p","k","q","all","_loadImage","_drawToCanvas","Worker","g","_postWorkerMessageSync","l","v","w","u","r","y","t","data","clearTimeout","cornerPoints","_convertPoints","NO_QR_CODE_FOUND","x","getImageData","buffer","race","detect","rawValue","message","test","_disableBarcodeDetector","setGrayscaleWeights","red","green","blue","useIntegerApproximation","setInversionMode","then","createWorker","BarcodeDetector","getSupportedFormats","includes","userAgentData","brands","some","_ref","brand","platform","getHighEntropyValues","_ref2","architecture","platformVersion","parseInt","formats","_scanFrame","Math","round","min","videoWidth","videoHeight","downScaledWidth","downScaledHeight","offsetWidth","offsetHeight","offsetLeft","objectFit","objectPosition","split","parseFloat","endsWith","top","left","paused","ended","requestVideoFrameCallback","async","readyState","Date","now","_codeOutlineHighlightRemovalTimeout","setAttribute","_ref3","join","log","Object","assign","exact","_getFacingMode","getTracks","removeTrack","getContext","alpha","imageSmoothingEnabled","drawImage","Image","_awaitImageLoad","HTMLVideoElement","HTMLCanvasElement","SVGImageElement","OffscreenCanvas","ImageBitmap","File","Blob","URL","src","createObjectURL","toString","revokeObjectURL","complete","naturalWidth","ErrorEvent","_workerMessageId","postMessage","type"],"sourceRoot":""}